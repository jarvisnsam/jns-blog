<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8"/>
    <link rel="icon" type="image/png" href="/img/jns_logo.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Blog - Jarvis and Sam | AI Solutions & Business Transformation</title>
    
    <!-- Initialize dataLayer -->
    <script>
      window.dataLayer = window.dataLayer || [];
    </script>
    
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-TRT4SWZC');</script>
    <!-- End Google Tag Manager -->
    
    <!-- Primary Meta Tags -->
    <meta name="description" content="Explore insights on AI technologies, business transformation, and innovative solutions from Jarvis and Sam's expert blog." />
    <meta name="keywords" content="AI blog, business transformation, AI agents, automation insights, data analysis, workflow optimization" />
    <meta name="author" content="Jarvis and Sam" />
    
    <!-- RSS Feed Auto-discovery -->
    <link rel="alternate" type="application/rss+xml" title="Jarvis and Sam AI Blog RSS Feed" href="/feed.xml" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://jarvisnsam.com/jns-blog/" />
    <meta property="og:site_name" content="Jarvis and Sam Blog" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:title" content="Blog - Jarvis and Sam | AI Solutions & Business Transformation" />
    <meta property="og:description" content="Explore insights on AI technologies, business transformation, and innovative solutions from Jarvis and Sam's expert blog." />
    <meta property="og:image" content="https://jarvisnsam.com/jns-blog/img/jns_logo.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://jarvisnsam.com/jns-blog/" />
    <meta property="twitter:site" content="@jarvisnsam" />
    <meta property="twitter:title" content="Blog - Jarvis and Sam | AI Solutions & Business Transformation" />
    <meta property="twitter:description" content="Explore insights on AI technologies, business transformation, and innovative solutions from Jarvis and Sam's expert blog." />
    <meta property="twitter:image" content="https://jarvisnsam.com/jns-blog/img/jns_logo.png" />
    
    <!-- Fonts -->
    <link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
    <link as="style" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Newsreader%3Awght%40400%3B500%3B600%3B700%3B800&amp;family=Noto+Sans%3Awght%40400%3B500%3B600%3B700%3B900" onload="this.rel='stylesheet'" rel="stylesheet"/>
    
    <!-- Styles -->
    <link rel="stylesheet" href="/css/blog-common.css">
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <style>
        /* Container max-width matching blog-common.css */
        .container {
          width: 100%;
          padding-right: 15px;
          padding-left: 15px;
          margin-right: auto;
          margin-left: auto;
        }
        @media (min-width: 576px) {
          .container { max-width: 540px; }
        }
        @media (min-width: 768px) {
          .container { max-width: 720px; }
        }
        @media (min-width: 992px) {
          .container { max-width: 960px; }
        }
        @media (min-width: 1200px) {
          .container { max-width: 1200px; }
        }
        @media (min-width: 1400px) {
          .container { max-width: 1200px; }
        }
        
        /* Content Styles */
        .loading-placeholder {
          animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        .loading-placeholder {
          background: linear-gradient(90deg, var(--border-color) 25%, transparent 50%, var(--border-color) 75%);
          background-size: 200% 100%;
          animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
          0% { background-position: 200% 0; }
          100% { background-position: -200% 0; }
        }
        .hero-image {
          object-fit: cover;
          object-position: center;
        }
        
        /* Line clamp utilities for consistent card heights */
        .line-clamp-2 {
          display: -webkit-box;
          -webkit-line-clamp: 2;
          -webkit-box-orient: vertical;
          overflow: hidden;
          text-overflow: ellipsis;
          line-height: 1.4;
          max-height: 2.8em; /* 2 lines * 1.4 line-height */
        }
        
        .line-clamp-3 {
          display: -webkit-box;
          -webkit-line-clamp: 3;
          -webkit-box-orient: vertical;
          overflow: hidden;
          text-overflow: ellipsis;
          line-height: 1.5;
          max-height: 4.5em; /* 3 lines * 1.5 line-height */
        }
        
        /* Ensure main content area respects max-width */
        .layout-content-container {
          max-width: 1200px;
          margin: 0 auto;
        }
      </style>
    </head>
    <body class="light-theme">
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TRT4SWZC"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    
    <!-- Header placeholder -->
    <div id="blog-header"></div>
    
    <div class="relative flex size-full min-h-screen flex-col group/design-root overflow-x-hidden">
      <main class="flex-1 bg-[var(--bg-color)]">
        <div class="container py-8">
          <div class="layout-content-container flex flex-col">
            <!-- Search and Filter Section -->
            <div class="mb-8">
              <div class="relative max-w-md mx-auto">
                <input 
                  type="text" 
                  id="search-input" 
                  placeholder="Search posts by title, content, or tags..." 
                  class="w-full px-6 py-3 pr-12 rounded-full border border-[var(--border-color)] bg-[var(--card-bg-color)] text-[var(--text-color)] placeholder-[var(--text-muted-color)] focus:outline-none focus:ring-2 focus:ring-[var(--primary-color)] focus:border-transparent transition-all"
                />
                <div class="absolute inset-y-0 right-0 flex items-center pr-4">
                  <svg class="w-5 h-5 text-[var(--text-muted-color)]" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                  </svg>
                </div>
              </div>
              
              <!-- Filter Status -->
              <div id="filter-status" class="text-center mt-4 hidden">
                <span class="text-sm text-[var(--text-muted-color)]" id="filter-text"></span>
                <button id="clear-filters" class="ml-2 text-sm text-[var(--primary-color)] hover:underline">Clear filters</button>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" id="blog-posts-container">
              
              <!-- Loading placeholders - will be replaced by dynamic content -->
              <article class="flex flex-col bg-[var(--card-bg-color)] rounded-lg shadow-md overflow-hidden border border-[var(--border-color)] loading-placeholder">
                <div class="w-full aspect-[16/10] bg-[var(--border-color)]"></div>
                <div class="p-5">
                  <div class="h-4 bg-[var(--border-color)] rounded mb-3 w-32"></div>
                  <div class="h-6 bg-[var(--border-color)] rounded mb-2"></div>
                  <div class="h-4 bg-[var(--border-color)] rounded mb-2"></div>
                  <div class="h-4 bg-[var(--border-color)] rounded w-3/4"></div>
                </div>
              </article>
              
              <article class="flex flex-col bg-[var(--card-bg-color)] rounded-lg shadow-md overflow-hidden border border-[var(--border-color)] loading-placeholder">
                <div class="w-full aspect-[16/10] bg-[var(--border-color)]"></div>
                <div class="p-5">
                  <div class="h-4 bg-[var(--border-color)] rounded mb-3 w-32"></div>
                  <div class="h-6 bg-[var(--border-color)] rounded mb-2"></div>
                  <div class="h-4 bg-[var(--border-color)] rounded mb-2"></div>
                  <div class="h-4 bg-[var(--border-color)] rounded w-3/4"></div>
                </div>
              </article>

            </div>
            
            <!-- Pagination -->
            <div id="pagination-container" class="mt-12 flex justify-center items-center space-x-2 hidden">
              <button id="prev-page" class="px-4 py-2 text-sm font-medium text-[var(--text-muted-color)] bg-[var(--card-bg-color)] border border-[var(--border-color)] rounded-lg hover:bg-[var(--border-color)] transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                Previous
              </button>
              <div id="page-numbers" class="flex space-x-1"></div>
              <button id="next-page" class="px-4 py-2 text-sm font-medium text-[var(--text-muted-color)] bg-[var(--card-bg-color)] border border-[var(--border-color)] rounded-lg hover:bg-[var(--border-color)] transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                Next
              </button>
            </div>
          </div>
        </main>
        
        <!-- Footer placeholder -->
        <div id="blog-footer"></div>
      </div>
    </div>
    
    <!-- Load common JS -->
    <script src="/js/blog-common.js"></script>
    
    <script>
        // Cache for parsed post metadata
        const postCache = new Map();
        const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

        // Parse sitemap XML to get list of pages
        async function parseSitemap() {
            try {
                const response = await fetch('/sitemap.xml');
                if (!response.ok) {
                    throw new Error('Failed to fetch sitemap');
                }
                
                const text = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'text/xml');
                
                // Get all URLs from sitemap
                const urls = Array.from(doc.querySelectorAll('url'))
                    .map(url => {
                        const loc = url.querySelector('loc')?.textContent;
                        const lastmod = url.querySelector('lastmod')?.textContent;
                        return { loc, lastmod };
                    })
                    .filter(url => url.loc && url.loc.includes('/pages/'))
                    .map(url => ({
                        ...url,
                        filename: url.loc.split('/pages/')[1]
                    }));
                
                return urls;
            } catch (error) {
                console.error('Error parsing sitemap:', error);
                // Fallback: try to discover files directly
                return discoverFilesDirectly();
            }
        }

        // Fallback method to discover files
        async function discoverFilesDirectly() {
            // This is a fallback - in production, sitemap should always work
            // But for local development, we can try known files
            const knownFiles = [
                'parellel_internet.html',
                'agentic protocol future trend.html'
            ];
            
            return knownFiles.map(filename => ({
                filename,
                loc: `/pages/${filename}`,
                lastmod: new Date().toISOString().split('T')[0]
            }));
        }

        // Extract metadata AND hero images from HTML content
        function extractPostMetadata(htmlContent, filename) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');
            
            // Extract title (try multiple sources)
            let title = doc.querySelector('title')?.textContent?.replace(' - AI KnowledgeBase', '')?.replace(' - Jarvis and Sam Blog', '') ||
                       doc.querySelector('article h1')?.textContent ||
                       doc.querySelector('h1')?.textContent ||
                       filename.replace('.html', '');
            
            // Extract description (try multiple sources)
            let description = doc.querySelector('meta[name="description"]')?.content ||
                             doc.querySelector('article p')?.textContent ||
                             doc.querySelector('p')?.textContent ||
                             'No description available';
            
            // Clean and truncate description for 3-row max display
            description = description.replace(/\s+/g, ' ').trim();
            if (description.length > 120) {
                description = description.substring(0, 117) + '...';
            }
            
            // Extract publication date
            const dateElement = doc.querySelector('time[datetime]');
            const publishDate = dateElement?.getAttribute('datetime') || 
                               doc.querySelector('meta[name="article:published_time"]')?.content ||
                               dateElement?.textContent || 
                               new Date().toISOString().split('T')[0];
            
            // Extract tags
            const tags = [];
            
            // From meta keywords
            const keywords = doc.querySelector('meta[name="keywords"]')?.content;
            if (keywords) {
                tags.push(...keywords.split(',').map(t => t.trim()));
            }
            
            // From article:tag meta tags
            const articleTags = doc.querySelectorAll('meta[name="article:tag"]');
            articleTags.forEach(tag => tags.push(tag.content));
            
            // From .tag elements in content
            const tagElements = doc.querySelectorAll('.tag');
            tagElements.forEach(tag => tags.push(tag.textContent.trim()));
            
            // Extract hero image - try multiple selectors for different blog post structures
            let heroImage = null;
            
            // Try to find the first image in the article (hero image patterns)
            const heroSelectors = [
                'figure img', // Figure with image (common pattern)
                'article img:first-of-type', // First image in article
                'img[alt*="hero"]', // Images with "hero" in alt text
                'img[src*="tvsa"]', // Specific hero images like tvsa.png
                '.hero-image img', // Images in hero containers
                '.featured-image img', // Featured image containers
                'article > div > img', // Direct article images
                'img' // Any image as fallback
            ];
            
            for (const selector of heroSelectors) {
                const imgElement = doc.querySelector(selector);
                if (imgElement) {
                    let src = imgElement.getAttribute('src');
                    if (src) {
                        // Handle relative paths - convert to work with root serving
                        if (src.startsWith('../img/')) {
                            src = src.replace('../img/', '/img/');
                        } else if (src.startsWith('./img/')) {
                            src = src.replace('./img/', '/img/');
                        } else if (src.startsWith('img/')) {
                            src = '/' + src;
                        } else if (!src.startsWith('/') && !src.startsWith('http')) {
                            src = '/img/' + src;
                        }
                        
                        heroImage = src;
                        break;
                    }
                }
            }
            
            return { 
                title, 
                description, 
                publishDate,
                tags: [...new Set(tags)], // Remove duplicates
                heroImage 
            };
        }

        // Format date for display
        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Fetch and parse post metadata
        async function fetchPostMetadata(post) {
            const cacheKey = `post-${post.filename}`;
            const cached = postCache.get(cacheKey);
            
            // Check cache validity
            if (cached && (Date.now() - cached.timestamp < CACHE_DURATION)) {
                return cached.data;
            }
            
            try {
                // Try multiple path variations for GitHub Pages compatibility
                const possiblePaths = [
                    `./pages/${post.filename}`,
                    `pages/${post.filename}`,
                    `/pages/${post.filename}`
                ];
                
                let response;
                let htmlContent;
                
                for (const path of possiblePaths) {
                    try {
                        response = await fetch(path);
                        if (response.ok) {
                            htmlContent = await response.text();
                            break;
                        }
                    } catch (pathError) {
                        console.warn(`Failed to fetch from ${path}:`, pathError);
                        continue;
                    }
                }
                
                if (!htmlContent) {
                    throw new Error(`Could not fetch ${post.filename} from any path`);
                }
                
                const metadata = extractPostMetadata(htmlContent, post.filename);
                
                // Merge with post data
                const result = {
                    ...metadata,
                    filename: post.filename,
                    lastmod: post.lastmod
                };
                
                // Cache the result
                postCache.set(cacheKey, {
                    data: result,
                    timestamp: Date.now()
                });
                
                return result;
            } catch (error) {
                console.warn(`Failed to fetch ${post.filename}:`, error);
                // Return minimal data when fetch fails
                return {
                    title: post.filename.replace('.html', '').replace(/-/g, ' '),
                    description: 'Unable to load description',
                    publishDate: post.lastmod || new Date().toISOString().split('T')[0],
                    tags: [],
                    heroImage: null,
                    filename: post.filename
                };
            }
        }

        // Generate gradient based on index
        function getGradient(index) {
            const gradients = [
                'from-blue-500 via-purple-600 to-teal-500',
                'from-orange-500 via-pink-500 to-purple-600',
                'from-green-500 via-teal-500 to-blue-600',
                'from-red-500 via-orange-500 to-yellow-500',
                'from-indigo-500 via-purple-500 to-pink-500'
            ];
            return gradients[index % gradients.length];
        }

        // Capitalize first letter of each word (title case)
        function toTitleCase(str) {
            return str.replace(/\w\S*/g, (txt) => 
                txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
            );
        }

        // Generate post card HTML with dynamic hero images
        function generatePostCard(post, index) {
            const shortTitle = post.title.length > 60 ? post.title.substring(0, 57) + '...' : post.title;
            const formattedDate = formatDate(post.publishDate);
            
            // Generate tags HTML with title case and click handlers
            const tagsHtml = post.tags.length > 0 
                ? post.tags.slice(0, 3).map(tag => 
                    `<span class="tag clickable-tag" data-tag="${tag}" onclick="filterByTag('${tag}')">${toTitleCase(tag)}</span>`
                  ).join('')
                : '';
            
            // Use hero image if available, otherwise use gradient fallback
            let heroContent;
            if (post.heroImage) {
                heroContent = `
                    <img src="${post.heroImage}" alt="${post.title}" class="w-full h-full hero-image" 
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                    <div class="w-full h-full bg-gradient-to-br ${getGradient(index)} flex items-center justify-center" style="display: none;">
                        <div class="text-white text-center p-4">
                            <div class="text-6xl mb-2">ðŸ“„</div>
                            <div class="text-sm font-semibold">Blog Post</div>
                        </div>
                    </div>
                `;
            } else {
                heroContent = `
                    <div class="w-full h-full bg-gradient-to-br ${getGradient(index)} flex items-center justify-center">
                        <div class="text-white text-center p-4">
                            <div class="text-6xl mb-2">ðŸ“„</div>
                            <div class="text-sm font-semibold">Blog Post</div>
                        </div>
                    </div>
                `;
            }
            
            return `
                <article class="flex flex-col bg-[var(--card-bg-color)] rounded-lg shadow-md overflow-hidden hover:shadow-xl transition-shadow duration-300 border border-[var(--border-color)]" data-tags="${post.tags.join(',')}" data-title="${post.title.toLowerCase()}" data-description="${post.description.toLowerCase()}">
                    <a class="block" href="./pages/${post.filename}">
                        <div class="w-full aspect-[16/10] overflow-hidden">
                            ${heroContent}
                        </div>
                    </a>
                    <div class="p-5 flex flex-col flex-grow">
                        <h3 class="text-[var(--text-color)] text-xl font-semibold leading-snug mb-2 line-clamp-2" style="font-family: Newsreader, serif;">
                            <a class="hover:text-blue-600 dark:hover:text-blue-400 transition-colors" href="./pages/${post.filename}">${shortTitle}</a>
                        </h3>
                        <p class="text-[var(--text-muted-color)] text-xs font-normal leading-relaxed flex-grow mb-2 line-clamp-3">
                            ${post.description}
                        </p>
                        ${tagsHtml ? `<div class="post-tags mb-2">${tagsHtml}</div>` : ''}
                        <div class="flex items-center justify-between mt-auto">
                            <a class="text-blue-600 dark:text-blue-400 text-sm font-semibold hover:underline" href="./pages/${post.filename}">Read article â†’</a>
                            <time class="text-[var(--text-muted-color)] text-xs">
                                ${formattedDate}
                            </time>
                        </div>
                    </div>
                </article>
            `;
        }

        // Global variables for filtering and pagination
        let allPosts = [];
        let filteredPosts = [];
        let currentSearchTerm = '';
        let currentTag = '';
        let currentPage = 1;
        const POSTS_PER_PAGE = 12;

        // Pagination functions
        function renderPagination(totalPosts) {
            const totalPages = Math.ceil(totalPosts / POSTS_PER_PAGE);
            const paginationContainer = document.getElementById('pagination-container');
            const pageNumbers = document.getElementById('page-numbers');
            const prevButton = document.getElementById('prev-page');
            const nextButton = document.getElementById('next-page');

            if (totalPages <= 1) {
                paginationContainer.classList.add('hidden');
                return;
            }

            paginationContainer.classList.remove('hidden');

            // Update prev/next buttons
            prevButton.disabled = currentPage === 1;
            nextButton.disabled = currentPage === totalPages;

            // Generate page numbers
            pageNumbers.innerHTML = '';
            
            // Show page numbers with ellipsis for large page counts
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }

            // First page
            if (startPage > 1) {
                pageNumbers.appendChild(createPageButton(1));
                if (startPage > 2) {
                    pageNumbers.appendChild(createEllipsis());
                }
            }

            // Visible pages
            for (let i = startPage; i <= endPage; i++) {
                pageNumbers.appendChild(createPageButton(i));
            }

            // Last page
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pageNumbers.appendChild(createEllipsis());
                }
                pageNumbers.appendChild(createPageButton(totalPages));
            }
        }

        function createPageButton(pageNum) {
            const button = document.createElement('button');
            button.textContent = pageNum;
            button.className = `px-3 py-2 text-sm font-medium rounded-lg transition-colors ${
                pageNum === currentPage 
                    ? 'bg-[var(--primary-color)] text-white' 
                    : 'text-[var(--text-muted-color)] bg-[var(--card-bg-color)] border border-[var(--border-color)] hover:bg-[var(--border-color)]'
            }`;
            button.onclick = () => goToPage(pageNum);
            return button;
        }

        function createEllipsis() {
            const span = document.createElement('span');
            span.textContent = '...';
            span.className = 'px-3 py-2 text-sm text-[var(--text-muted-color)]';
            return span;
        }

        function goToPage(page) {
            currentPage = page;
            displayCurrentPage();
        }

        function displayCurrentPage() {
            const startIndex = (currentPage - 1) * POSTS_PER_PAGE;
            const endIndex = startIndex + POSTS_PER_PAGE;
            const postsToShow = filteredPosts.slice(startIndex, endIndex);
            
            const container = document.getElementById('blog-posts-container');
            if (postsToShow.length === 0) {
                container.innerHTML = `
                    <div class="col-span-full text-center py-8">
                        <p class="text-[var(--text-muted-color)]">No posts found matching your criteria.</p>
                    </div>
                `;
            } else {
                container.innerHTML = postsToShow.map((post, index) => generatePostCard(post, startIndex + index)).join('');
            }
            
            renderPagination(filteredPosts.length);
        }

        // Filter posts by search term and/or tag with pagination
        function filterPosts(searchTerm = '', selectedTag = '') {
            const filterStatus = document.getElementById('filter-status');
            const filterText = document.getElementById('filter-text');
            
            // Update global state
            currentSearchTerm = searchTerm.toLowerCase();
            currentTag = selectedTag;
            currentPage = 1; // Reset to first page when filtering
            
            // Filter posts
            filteredPosts = allPosts.filter(post => {
                const matchesSearch = !currentSearchTerm || 
                    post.title.toLowerCase().includes(currentSearchTerm) ||
                    post.description.toLowerCase().includes(currentSearchTerm) ||
                    post.tags.some(tag => tag.toLowerCase().includes(currentSearchTerm));
                
                const matchesTag = !currentTag || 
                    post.tags.some(tag => tag.toLowerCase() === currentTag.toLowerCase());
                
                return matchesSearch && matchesTag;
            });
            
            // Display current page
            displayCurrentPage();
            
            // Update filter status
            if (currentSearchTerm || currentTag) {
                let statusText = `Showing ${filteredPosts.length} post${filteredPosts.length !== 1 ? 's' : ''}`;
                if (currentSearchTerm && currentTag) {
                    statusText += ` for "${currentSearchTerm}" in "${toTitleCase(currentTag)}"`;
                } else if (currentSearchTerm) {
                    statusText += ` for "${currentSearchTerm}"`;
                } else if (currentTag) {
                    statusText += ` tagged "${toTitleCase(currentTag)}"`;
                }
                filterText.textContent = statusText;
                filterStatus.classList.remove('hidden');
            } else {
                filterStatus.classList.add('hidden');
            }
            
            // Update URL
            updateURL();
        }

        // Filter by tag (called from tag clicks)
        function filterByTag(tag) {
            const searchInput = document.getElementById('search-input');
            filterPosts(searchInput.value, tag);
        }

        // Clear all filters
        function clearFilters() {
            const searchInput =
